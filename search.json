[
  {
    "objectID": "qmds_ghpages/index.html",
    "href": "qmds_ghpages/index.html",
    "title": "CAZ-health-data-trends",
    "section": "",
    "text": "This is a place holder for the main",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "qmds_ghpages/about.html",
    "href": "qmds_ghpages/about.html",
    "title": "About",
    "section": "",
    "text": "Place holder for the about section of this site",
    "crumbs": [
      "About"
    ]
  },
  {
    "objectID": "qmds_ghpages/CAZ_definition.html",
    "href": "qmds_ghpages/CAZ_definition.html",
    "title": "Clean Air Zones (CAZ)",
    "section": "",
    "text": "options(repos = c(CRAN = \"https://cloud.r-project.org\"))\nif (!require(\"remotes\")) install.packages(\"remotes\")\npkgs = c(\n    \"sf\",\n    \"tidyverse\",\n    \"here\",\n    \"tmap\"\n)\n\nremotes::install_cran(pkgs)\nsapply(pkgs, require, character.only = TRUE)\n\n       sf tidyverse      here      tmap \n     TRUE      TRUE      TRUE      TRUE \n\n\n\n\n\n\nThe boundaries have been obtained manually from the different official repositories and compiled in a single gpkg file. The url to the sources is available in the metadata file.\n\ndir.create(\"data_raw\",showWarnings = F)\nif (!file.exists(\"data_raw/CAZ_boundaries.gpkg\")){\n  u &lt;- \"https://github.com/itsleeds/CAZ-health-data-trends/releases/download/v0/CAZ_boundaries.gpkg\"\n  f &lt;- basename(u)\n  download.file(u,destfile = file.path(\"data_raw\",f),mode = \"wb\",)\n}\n\n\n\n\n\nif (!file.exists(\"data_raw/CAZ_list.csv\")){\n  u &lt;- \"https://github.com/itsleeds/CAZ-health-data-trends/releases/download/v0/CAZ_list.csv\"\n  f &lt;- basename(u)\n  download.file(u,destfile = file.path(\"data_raw\",f),mode = \"wb\",)\n}\n\n\n\n\n\n\ncaz_boundaries &lt;- st_read(file.path(here(),\"data_raw\",\"CAZ_boundaries.gpkg\"))\n\nReading layer `CAZ_boundaries' from data source \n  `C:\\temp_jf\\CAZ-health-data-trends\\data_raw\\CAZ_boundaries.gpkg' \n  using driver `GPKG'\nSimple feature collection with 7 features and 1 field\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 356346.4 ymin: 99474.13 xmax: 465151.9 ymax: 565398\nProjected CRS: OSGB36 / British National Grid\n\ncaz_metadata &lt;- read_csv(file.path(here(),\"data_raw\",\"CAZ_list.csv\"))\n\nRows: 14 Columns: 6\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (5): CAZ, Area, Type, file, Source\ndbl (1): Start\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\n\n\n\nbuffers &lt;- c(0,0.5,1,5,10)*1e3\n\ncaz_buffers &lt;- lapply(buffers, \\(buff_dist) {\n  st_buffer(caz_boundaries, dist = buff_dist) |&gt;\n    mutate(buffer_km = buff_dist / 1e3)\n}) |&gt;\n  bind_rows()\n\n\nst_write(caz_buffers,file.path(here(),\"data_raw\",\"CAZ_buffers.gpkg\"),append = FALSE)\n\nDeleting layer `CAZ_buffers' using driver `GPKG'\nWriting layer `CAZ_buffers' to data source \n  `C:/temp_jf/CAZ-health-data-trends/data_raw/CAZ_buffers.gpkg' using driver `GPKG'\nWriting 35 features with 2 fields and geometry type Polygon.\n\n\nA quick visualisation\n\ntmap_mode(\"view\")\n\nℹ tmap mode set to \"view\".\n\ntm_shape(caz_buffers |&gt; arrange(-buffer_km))+\n  tm_polygons(\"buffer_km\",\n              fill_alpha = 0.4,\n              fill.scale = tm_scale_discrete(ticks = buffers/1e3,\n                                             values = \"-brewer.blues\")\n              )",
    "crumbs": [
      "Data",
      "Clean Air Zones"
    ]
  },
  {
    "objectID": "qmds_ghpages/CAZ_definition.html#downloading-data",
    "href": "qmds_ghpages/CAZ_definition.html#downloading-data",
    "title": "Clean Air Zones (CAZ)",
    "section": "",
    "text": "The boundaries have been obtained manually from the different official repositories and compiled in a single gpkg file. The url to the sources is available in the metadata file.\n\ndir.create(\"data_raw\",showWarnings = F)\nif (!file.exists(\"data_raw/CAZ_boundaries.gpkg\")){\n  u &lt;- \"https://github.com/itsleeds/CAZ-health-data-trends/releases/download/v0/CAZ_boundaries.gpkg\"\n  f &lt;- basename(u)\n  download.file(u,destfile = file.path(\"data_raw\",f),mode = \"wb\",)\n}\n\n\n\n\n\nif (!file.exists(\"data_raw/CAZ_list.csv\")){\n  u &lt;- \"https://github.com/itsleeds/CAZ-health-data-trends/releases/download/v0/CAZ_list.csv\"\n  f &lt;- basename(u)\n  download.file(u,destfile = file.path(\"data_raw\",f),mode = \"wb\",)\n}",
    "crumbs": [
      "Data",
      "Clean Air Zones"
    ]
  },
  {
    "objectID": "qmds_ghpages/CAZ_definition.html#loading-data",
    "href": "qmds_ghpages/CAZ_definition.html#loading-data",
    "title": "Clean Air Zones (CAZ)",
    "section": "",
    "text": "caz_boundaries &lt;- st_read(file.path(here(),\"data_raw\",\"CAZ_boundaries.gpkg\"))\n\nReading layer `CAZ_boundaries' from data source \n  `C:\\temp_jf\\CAZ-health-data-trends\\data_raw\\CAZ_boundaries.gpkg' \n  using driver `GPKG'\nSimple feature collection with 7 features and 1 field\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 356346.4 ymin: 99474.13 xmax: 465151.9 ymax: 565398\nProjected CRS: OSGB36 / British National Grid\n\ncaz_metadata &lt;- read_csv(file.path(here(),\"data_raw\",\"CAZ_list.csv\"))\n\nRows: 14 Columns: 6\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (5): CAZ, Area, Type, file, Source\ndbl (1): Start\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.",
    "crumbs": [
      "Data",
      "Clean Air Zones"
    ]
  },
  {
    "objectID": "qmds_ghpages/CAZ_definition.html#processing-buffers",
    "href": "qmds_ghpages/CAZ_definition.html#processing-buffers",
    "title": "Clean Air Zones (CAZ)",
    "section": "",
    "text": "buffers &lt;- c(0,0.5,1,5,10)*1e3\n\ncaz_buffers &lt;- lapply(buffers, \\(buff_dist) {\n  st_buffer(caz_boundaries, dist = buff_dist) |&gt;\n    mutate(buffer_km = buff_dist / 1e3)\n}) |&gt;\n  bind_rows()\n\n\nst_write(caz_buffers,file.path(here(),\"data_raw\",\"CAZ_buffers.gpkg\"),append = FALSE)\n\nDeleting layer `CAZ_buffers' using driver `GPKG'\nWriting layer `CAZ_buffers' to data source \n  `C:/temp_jf/CAZ-health-data-trends/data_raw/CAZ_buffers.gpkg' using driver `GPKG'\nWriting 35 features with 2 fields and geometry type Polygon.\n\n\nA quick visualisation\n\ntmap_mode(\"view\")\n\nℹ tmap mode set to \"view\".\n\ntm_shape(caz_buffers |&gt; arrange(-buffer_km))+\n  tm_polygons(\"buffer_km\",\n              fill_alpha = 0.4,\n              fill.scale = tm_scale_discrete(ticks = buffers/1e3,\n                                             values = \"-brewer.blues\")\n              )",
    "crumbs": [
      "Data",
      "Clean Air Zones"
    ]
  },
  {
    "objectID": "qmds_ghpages/practice_data.html",
    "href": "qmds_ghpages/practice_data.html",
    "title": "GP Practices",
    "section": "",
    "text": "options(repos = c(CRAN = \"https://cloud.r-project.org\"))\nif (!require(\"remotes\")) install.packages(\"remotes\")\npkgs = c(\n    \"sf\",\n    \"tidyverse\",\n    \"here\",\n    \"tmap\",\n    \"geojsonsf\",\n    \"rvest\"\n)\n\nremotes::install_cran(pkgs)\nsapply(pkgs, require, character.only = TRUE)\n\n       sf tidyverse      here      tmap geojsonsf     rvest \n     TRUE      TRUE      TRUE      TRUE      TRUE      TRUE \n\n\n\n\n\n\n\nif (!file.exists(\"data_raw/subicb_boundaries.gpkg\")){\n  \n  u &lt;- \"https://openprescribing.net/api/1.0/org_location/?org_type=ccg\"\n  subicb_boundaries &lt;- geojsonsf::geojson_sf(u) |&gt;\n    st_transform(27700)\n  \n  st_write(subicb_boundaries,\n           dsn = file.path(here(),\"data_raw\",\"subicb_boundaries.gpkg\"),\n           append = FALSE\n           )\n} else{\n  subicb_boundaries &lt;- st_read(file.path(here(),\"data_raw\",\"subicb_boundaries.gpkg\"))\n}\n\nDeleting layer `subicb_boundaries' using driver `GPKG'\nWriting layer `subicb_boundaries' to data source \n  `C:/temp_jf/CAZ-health-data-trends/data_raw/subicb_boundaries.gpkg' using driver `GPKG'\nWriting 106 features with 4 fields and geometry type Unknown (any).\n\n\n\n\n\nObtaining the location of GP practices from OpenPrescribing for each Sub-ICB\n\nif (!file.exists(\"data_raw/gp_locations.gpkg\")){\n  \n  all_practices &lt;- lapply(subicb_boundaries$code,\n                              \\(t_code) {\n                                geojsonsf::geojson_sf(\n                                  paste0(\"https://openprescribing.net/api/1.0/org_location/?q=\",\n                                         t_code)) |&gt;\n                                  st_transform(27700) |&gt; \n                                  mutate(par_code = t_code)\n  }) |&gt; \n    bind_rows()\n  \n  st_write(all_practices,\n           dsn = file.path(here(),\"data_raw\",\"gp_locations.gpkg\"),\n           append = FALSE\n           )\n} else{\n  all_practices &lt;- st_read(file.path(here(),\"data_raw\",\"gp_locations.gpkg\"))\n}\n\nDeleting layer `gp_locations' using driver `GPKG'\nWriting layer `gp_locations' to data source \n  `C:/temp_jf/CAZ-health-data-trends/data_raw/gp_locations.gpkg' using driver `GPKG'\nWriting 11968 features with 4 fields and geometry type Point.\n\n\n\n\n\n\ncaz_buffers &lt;- st_read(file.path(here(),\"data_raw\",\"CAZ_buffers.gpkg\"))\n\nReading layer `CAZ_buffers' from data source \n  `C:\\temp_jf\\CAZ-health-data-trends\\data_raw\\CAZ_buffers.gpkg' \n  using driver `GPKG'\nSimple feature collection with 35 features and 2 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 346347.5 ymin: 89474.96 xmax: 475150.8 ymax: 575397.8\nProjected CRS: OSGB36 / British National Grid\n\n\nSub-setting the practices within the buffers\n\ncaz_practices &lt;- all_practices[caz_buffers,]\n\nDetecting intersections and extracting the minimum buffer size\n\npractices_intersects &lt;- st_intersects(caz_practices,caz_buffers)\n\ncaz_practices$buffer_km &lt;- vapply(practices_intersects,\n       \\(caz_index){ caz_buffers$buffer_km[caz_index] |&gt; min()},\n       FUN.VALUE = numeric(1))\n\ncaz_practices$CAZ_name &lt;- vapply(practices_intersects,\n       \\(caz_index){caz_buffers$name[caz_index][which.min(caz_buffers$buffer_km[caz_index])]},\n       FUN.VALUE = character(1))\n\n\ntmap_mode(\"view\")\n\nℹ tmap mode set to \"view\".\n\nbuffers &lt;- c(0,0.5,1,5,10)*1e3\n\ntm_shape(caz_buffers |&gt; arrange(-buffer_km))+\n  tm_polygons(\"buffer_km\",\n              fill_alpha = 0.4,\n              fill.scale = tm_scale_discrete(ticks = buffers/1e3,\n                                             values = \"-brewer.blues\")\n              )+\ntm_shape(caz_practices)+\n  tm_dots(\"CAZ_name\")\n\nRegistered S3 method overwritten by 'jsonify':\n  method     from    \n  print.json jsonlite\n\n\n\n\n\n\n\n\n\n\n\n\nFrom the NHS we can extract total number of patients registered after each month. This code downloads all monthly reports programmatically, extracts the zip files, and saves a consolidated dataset as a csv file.\n\nif (!file.exists(file.path(here(),\"data_raw\",\"practice_patients.csv\"))){\n  \n  get_patients &lt;- function(){\n  base_u &lt;- \"https://digital.nhs.uk/data-and-information/publications/statistical/patients-registered-at-a-gp-practice/\"\n  \n  my_grid &lt;- expand.grid(month = tolower(month.name), year = 2020:2024)\n  my_grid$u &lt;- paste(my_grid$month, my_grid$year, sep = \"-\")\n  \n  folder_path &lt;- \"gp_patients\"\n  \n  dir.create(path = folder_path, showWarnings = F)\n  \n  cur_files &lt;- tools::file_path_sans_ext(list.files(folder_path))\n  \n  my_grid &lt;- my_grid[!(my_grid$u %in% cur_files), ]\n  \n  for (i in my_grid$u) {\n    print(paste0(base_u, i))\n    w &lt;- read_html(paste0(base_u, i))\n    \n    links &lt;- w  |&gt; html_nodes(\"a\")  |&gt; html_attr(\"href\")\n    \n    my_link &lt;- links[grep(links, pattern = \"gp-reg-pat-prac-all\")]\n    \n    download.file(\n      url = my_link,\n      destfile = paste0(folder_path, \"/\", i, \".\", tools::file_ext(my_link)),\n      mode = \"wb\"\n    )\n    \n    Sys.sleep(rnorm(1, mean = 5))\n  }\n  \n  # List all ZIP files in the folder\n  zip_files &lt;- list.files(path = folder_path,\n                          pattern = \"\\\\.zip$\",\n                          full.names = TRUE)\n  \n  # Extract each ZIP file\n  lapply(zip_files, function(zip_file) {\n    # Create a temporary directory for extraction\n    temp_dir &lt;- tempfile()\n    dir.create(temp_dir)\n    \n    # Extract the ZIP file into the temporary directory\n    unzip(zip_file, exdir = temp_dir)\n    \n    # List extracted files\n    extracted_files &lt;- list.files(path = temp_dir, full.names = TRUE)\n    \n    # Move and rename each extracted file to the original folder\n    lapply(extracted_files, function(file) {\n      file_extension &lt;- tools::file_ext(file)\n      new_name &lt;- file.path(folder_path,\n                            paste0(\n                              tools::file_path_sans_ext(basename(zip_file)),\n                              \".\",\n                              file_extension\n                            ))\n      file.rename(file, new_name)\n    })\n    \n    \n    # Remove the temporary directory\n    unlink(temp_dir, recursive = TRUE)\n  })\n  \n  \n  \n  all_data &lt;- lapply(list.files(\n    path = \"gp_patients\",\n    pattern = \"\\\\.csv$\",\n    full.names = T\n  ),\n  \\(x) {\n    read_csv(x) |&gt;\n      mutate(\n        month = str_extract(basename(x), \"[a-zA-Z]+(?=-)\"),\n        year = str_extract(basename(x), \"\\\\d{4}\")\n      )\n  })\n  \n  \n  common_names &lt;- reduce(lapply(all_data, names), intersect)\n  \n  all_data_df &lt;- do.call(rbind, lapply(all_data, \\(x) {\n    x[, common_names]\n  })) |&gt;\n    mutate(year = as.integer(year))\n  \n  write_csv(all_data_df,\n            file = file.path(here(),\"data_raw\",\"practice_patients.csv\"))\n  \n  }\n  \n  \n  get_patients()\n  \n  \n} else{\n  all_data_df &lt;- read_csv(file.path(here(),\"data_raw\",\"practice_patients.csv\"),\n                          col_types = cols(\n  PUBLICATION = col_character(),\n  EXTRACT_DATE = col_character(),\n  TYPE = col_character(),\n  CODE = col_character(),\n  POSTCODE = col_character(),\n  SEX = col_character(),\n  AGE = col_character(),\n  NUMBER_OF_PATIENTS = col_double(),\n  month = col_character(),\n  year = col_double()\n))\n}\n\n\n\n\ntmap_mode(\"plot\")\n\nℹ tmap mode set to \"plot\".\n\nsf_practices_size &lt;- all_practices |&gt;\n  left_join(all_data_df |&gt; \n  summarise(across(NUMBER_OF_PATIENTS,\\(x) median(x,na.rm = T)),.by = CODE),\n  by = c(\"code\" = \"CODE\"))\n\nsf_practices_size |&gt; \n  filter(NUMBER_OF_PATIENTS&lt;= quantile(NUMBER_OF_PATIENTS,0.9,na.rm = T)) |&gt; \n  arrange(-NUMBER_OF_PATIENTS) |&gt; \ntm_shape()+\n  tm_symbols(fill = \"NUMBER_OF_PATIENTS\",\n          size = \"NUMBER_OF_PATIENTS\",\n          col = NA,\n          size.scale = tm_scale_continuous(values.scale = 0.5),\n          size.legend = tm_legend_hide(),\n          # fill_alpha = 0.4,\n          fill.scale = tm_scale_intervals(n = 5, values = \"-tol.rainbow_wh_br\"))",
    "crumbs": [
      "Data",
      "GP Practices"
    ]
  },
  {
    "objectID": "qmds_ghpages/practice_data.html#loading-spatial-data",
    "href": "qmds_ghpages/practice_data.html#loading-spatial-data",
    "title": "GP Practices",
    "section": "",
    "text": "if (!file.exists(\"data_raw/subicb_boundaries.gpkg\")){\n  \n  u &lt;- \"https://openprescribing.net/api/1.0/org_location/?org_type=ccg\"\n  subicb_boundaries &lt;- geojsonsf::geojson_sf(u) |&gt;\n    st_transform(27700)\n  \n  st_write(subicb_boundaries,\n           dsn = file.path(here(),\"data_raw\",\"subicb_boundaries.gpkg\"),\n           append = FALSE\n           )\n} else{\n  subicb_boundaries &lt;- st_read(file.path(here(),\"data_raw\",\"subicb_boundaries.gpkg\"))\n}\n\nDeleting layer `subicb_boundaries' using driver `GPKG'\nWriting layer `subicb_boundaries' to data source \n  `C:/temp_jf/CAZ-health-data-trends/data_raw/subicb_boundaries.gpkg' using driver `GPKG'\nWriting 106 features with 4 fields and geometry type Unknown (any).\n\n\n\n\n\nObtaining the location of GP practices from OpenPrescribing for each Sub-ICB\n\nif (!file.exists(\"data_raw/gp_locations.gpkg\")){\n  \n  all_practices &lt;- lapply(subicb_boundaries$code,\n                              \\(t_code) {\n                                geojsonsf::geojson_sf(\n                                  paste0(\"https://openprescribing.net/api/1.0/org_location/?q=\",\n                                         t_code)) |&gt;\n                                  st_transform(27700) |&gt; \n                                  mutate(par_code = t_code)\n  }) |&gt; \n    bind_rows()\n  \n  st_write(all_practices,\n           dsn = file.path(here(),\"data_raw\",\"gp_locations.gpkg\"),\n           append = FALSE\n           )\n} else{\n  all_practices &lt;- st_read(file.path(here(),\"data_raw\",\"gp_locations.gpkg\"))\n}\n\nDeleting layer `gp_locations' using driver `GPKG'\nWriting layer `gp_locations' to data source \n  `C:/temp_jf/CAZ-health-data-trends/data_raw/gp_locations.gpkg' using driver `GPKG'\nWriting 11968 features with 4 fields and geometry type Point.\n\n\n\n\n\n\ncaz_buffers &lt;- st_read(file.path(here(),\"data_raw\",\"CAZ_buffers.gpkg\"))\n\nReading layer `CAZ_buffers' from data source \n  `C:\\temp_jf\\CAZ-health-data-trends\\data_raw\\CAZ_buffers.gpkg' \n  using driver `GPKG'\nSimple feature collection with 35 features and 2 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 346347.5 ymin: 89474.96 xmax: 475150.8 ymax: 575397.8\nProjected CRS: OSGB36 / British National Grid\n\n\nSub-setting the practices within the buffers\n\ncaz_practices &lt;- all_practices[caz_buffers,]\n\nDetecting intersections and extracting the minimum buffer size\n\npractices_intersects &lt;- st_intersects(caz_practices,caz_buffers)\n\ncaz_practices$buffer_km &lt;- vapply(practices_intersects,\n       \\(caz_index){ caz_buffers$buffer_km[caz_index] |&gt; min()},\n       FUN.VALUE = numeric(1))\n\ncaz_practices$CAZ_name &lt;- vapply(practices_intersects,\n       \\(caz_index){caz_buffers$name[caz_index][which.min(caz_buffers$buffer_km[caz_index])]},\n       FUN.VALUE = character(1))\n\n\ntmap_mode(\"view\")\n\nℹ tmap mode set to \"view\".\n\nbuffers &lt;- c(0,0.5,1,5,10)*1e3\n\ntm_shape(caz_buffers |&gt; arrange(-buffer_km))+\n  tm_polygons(\"buffer_km\",\n              fill_alpha = 0.4,\n              fill.scale = tm_scale_discrete(ticks = buffers/1e3,\n                                             values = \"-brewer.blues\")\n              )+\ntm_shape(caz_practices)+\n  tm_dots(\"CAZ_name\")\n\nRegistered S3 method overwritten by 'jsonify':\n  method     from    \n  print.json jsonlite",
    "crumbs": [
      "Data",
      "GP Practices"
    ]
  },
  {
    "objectID": "qmds_ghpages/practice_data.html#registered-patients-data",
    "href": "qmds_ghpages/practice_data.html#registered-patients-data",
    "title": "GP Practices",
    "section": "",
    "text": "From the NHS we can extract total number of patients registered after each month. This code downloads all monthly reports programmatically, extracts the zip files, and saves a consolidated dataset as a csv file.\n\nif (!file.exists(file.path(here(),\"data_raw\",\"practice_patients.csv\"))){\n  \n  get_patients &lt;- function(){\n  base_u &lt;- \"https://digital.nhs.uk/data-and-information/publications/statistical/patients-registered-at-a-gp-practice/\"\n  \n  my_grid &lt;- expand.grid(month = tolower(month.name), year = 2020:2024)\n  my_grid$u &lt;- paste(my_grid$month, my_grid$year, sep = \"-\")\n  \n  folder_path &lt;- \"gp_patients\"\n  \n  dir.create(path = folder_path, showWarnings = F)\n  \n  cur_files &lt;- tools::file_path_sans_ext(list.files(folder_path))\n  \n  my_grid &lt;- my_grid[!(my_grid$u %in% cur_files), ]\n  \n  for (i in my_grid$u) {\n    print(paste0(base_u, i))\n    w &lt;- read_html(paste0(base_u, i))\n    \n    links &lt;- w  |&gt; html_nodes(\"a\")  |&gt; html_attr(\"href\")\n    \n    my_link &lt;- links[grep(links, pattern = \"gp-reg-pat-prac-all\")]\n    \n    download.file(\n      url = my_link,\n      destfile = paste0(folder_path, \"/\", i, \".\", tools::file_ext(my_link)),\n      mode = \"wb\"\n    )\n    \n    Sys.sleep(rnorm(1, mean = 5))\n  }\n  \n  # List all ZIP files in the folder\n  zip_files &lt;- list.files(path = folder_path,\n                          pattern = \"\\\\.zip$\",\n                          full.names = TRUE)\n  \n  # Extract each ZIP file\n  lapply(zip_files, function(zip_file) {\n    # Create a temporary directory for extraction\n    temp_dir &lt;- tempfile()\n    dir.create(temp_dir)\n    \n    # Extract the ZIP file into the temporary directory\n    unzip(zip_file, exdir = temp_dir)\n    \n    # List extracted files\n    extracted_files &lt;- list.files(path = temp_dir, full.names = TRUE)\n    \n    # Move and rename each extracted file to the original folder\n    lapply(extracted_files, function(file) {\n      file_extension &lt;- tools::file_ext(file)\n      new_name &lt;- file.path(folder_path,\n                            paste0(\n                              tools::file_path_sans_ext(basename(zip_file)),\n                              \".\",\n                              file_extension\n                            ))\n      file.rename(file, new_name)\n    })\n    \n    \n    # Remove the temporary directory\n    unlink(temp_dir, recursive = TRUE)\n  })\n  \n  \n  \n  all_data &lt;- lapply(list.files(\n    path = \"gp_patients\",\n    pattern = \"\\\\.csv$\",\n    full.names = T\n  ),\n  \\(x) {\n    read_csv(x) |&gt;\n      mutate(\n        month = str_extract(basename(x), \"[a-zA-Z]+(?=-)\"),\n        year = str_extract(basename(x), \"\\\\d{4}\")\n      )\n  })\n  \n  \n  common_names &lt;- reduce(lapply(all_data, names), intersect)\n  \n  all_data_df &lt;- do.call(rbind, lapply(all_data, \\(x) {\n    x[, common_names]\n  })) |&gt;\n    mutate(year = as.integer(year))\n  \n  write_csv(all_data_df,\n            file = file.path(here(),\"data_raw\",\"practice_patients.csv\"))\n  \n  }\n  \n  \n  get_patients()\n  \n  \n} else{\n  all_data_df &lt;- read_csv(file.path(here(),\"data_raw\",\"practice_patients.csv\"),\n                          col_types = cols(\n  PUBLICATION = col_character(),\n  EXTRACT_DATE = col_character(),\n  TYPE = col_character(),\n  CODE = col_character(),\n  POSTCODE = col_character(),\n  SEX = col_character(),\n  AGE = col_character(),\n  NUMBER_OF_PATIENTS = col_double(),\n  month = col_character(),\n  year = col_double()\n))\n}\n\n\n\n\ntmap_mode(\"plot\")\n\nℹ tmap mode set to \"plot\".\n\nsf_practices_size &lt;- all_practices |&gt;\n  left_join(all_data_df |&gt; \n  summarise(across(NUMBER_OF_PATIENTS,\\(x) median(x,na.rm = T)),.by = CODE),\n  by = c(\"code\" = \"CODE\"))\n\nsf_practices_size |&gt; \n  filter(NUMBER_OF_PATIENTS&lt;= quantile(NUMBER_OF_PATIENTS,0.9,na.rm = T)) |&gt; \n  arrange(-NUMBER_OF_PATIENTS) |&gt; \ntm_shape()+\n  tm_symbols(fill = \"NUMBER_OF_PATIENTS\",\n          size = \"NUMBER_OF_PATIENTS\",\n          col = NA,\n          size.scale = tm_scale_continuous(values.scale = 0.5),\n          size.legend = tm_legend_hide(),\n          # fill_alpha = 0.4,\n          fill.scale = tm_scale_intervals(n = 5, values = \"-tol.rainbow_wh_br\"))",
    "crumbs": [
      "Data",
      "GP Practices"
    ]
  }
]